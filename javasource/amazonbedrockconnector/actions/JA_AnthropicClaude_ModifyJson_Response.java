// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package amazonbedrockconnector.actions;

import static java.util.Objects.requireNonNull;
import java.util.ArrayList;
import java.util.List;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import amazonbedrockconnector.impl.MxLogger;

public class JA_AnthropicClaude_ModifyJson_Response extends CustomJavaAction<java.lang.String>
{
	private java.lang.String ResponseBody_ToBeModified;

	public JA_AnthropicClaude_ModifyJson_Response(IContext context, java.lang.String ResponseBody_ToBeModified)
	{
		super(context);
		this.ResponseBody_ToBeModified = ResponseBody_ToBeModified;
	}

	@java.lang.Override
	public java.lang.String executeAction() throws Exception
	{
		// BEGIN USER CODE
		try {
			requireNonNull(this.ResponseBody_ToBeModified, "ResponseBody String is required");
			
			ObjectNode root = (ObjectNode) MAPPER.readTree(ResponseBody_ToBeModified);
			
			ArrayNode contentNode = (ArrayNode) root.get("content");
			
			List<JsonNode> toolUseList = getToolUseList(contentNode);
			
			if (toolUseList.size() > 0) {
				// Clear the content node
				contentNode.removeAll();
				
				// Get object with tool uses in right format for import mapping
				ObjectNode toolUseResponseNode = getToolUseResponseNode(toolUseList);
				//append to content node
				contentNode.add(toolUseResponseNode);
				
			}
			
			return MAPPER.writeValueAsString(root);
			
			
		} catch (Exception e) {
			LOGGER.error("Error occurred while modifying Claude response body: " + e.getMessage());
			throw e;
		}
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "JA_AnthropicClaude_ModifyJson_Response";
	}

	// BEGIN EXTRA CODE
	private static final MxLogger LOGGER = new MxLogger(JA_AnthropicClaude_ModifyJson_Response.class);
	private static final ObjectMapper MAPPER = new ObjectMapper();
	
	private List<JsonNode> getToolUseList(ArrayNode contentNode) {
		List<JsonNode> toolUseList = new ArrayList<>();
		for (JsonNode content : contentNode) {
			String type = content.get("type").asText();
			if (type.equals("tool_use")) {
				toolUseList.add(content);
			}
		}
		
		return toolUseList;
	}
	
	private ObjectNode getToolUseResponseNode(List<JsonNode> toolUseList) {
		ObjectNode toolUseResponseNode = MAPPER.createObjectNode();
		toolUseResponseNode.put("type", "text");
		
		ArrayNode toolUsesNode = MAPPER.createArrayNode();
		toolUseList.forEach(toolUse -> {
			ObjectNode toolUseNode = MAPPER.createObjectNode();
			toolUseNode.put("name", toolUse.get("name").asText());
			toolUseNode.put("id", toolUse.get("id").asText());
			
			String arguments = toolUse.get("input").toString();
			toolUseNode.put("arguments", arguments);
			
			toolUsesNode.add(toolUseNode);
		});
		
		toolUseResponseNode.set("toolCall", toolUsesNode);
		
		return toolUseResponseNode;
	}
	
	// END EXTRA CODE
}
