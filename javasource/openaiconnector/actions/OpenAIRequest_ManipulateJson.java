// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package openaiconnector.actions;

import static java.util.Objects.requireNonNull;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.HashMap;
import java.util.stream.Collectors;
import com.mendix.core.Core;
import com.mendix.core.CoreException;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import openaiconnector.impl.MxLogger;
import openaiconnector.proxies.ENUM_ToolChoice;
import openaiconnector.proxies.ToolRequest;
import openaiconnector.proxies.Tools;
import openaiconnector.proxies.FunctionRequest;
import openaiconnector.proxies.ToolCall;
import openaiconnector.proxies.ChatCompletionsMessageRequest;
import openaiconnector.proxies.ChatCompletionsMessages;
import openaiconnector.proxies.ENUM_Role;
import openaiconnector.impl.ChatCompletionsMessageRequestImpl;
import openaiconnector.impl.FunctionImpl;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.ArrayNode;

public class OpenAIRequest_ManipulateJson extends CustomJavaAction<java.lang.String>
{
	private IMendixObject __OpenAIRequest;
	private openaiconnector.proxies.OpenAIRequest OpenAIRequest;
	private java.lang.String OpenAIRequest_Json;

	public OpenAIRequest_ManipulateJson(IContext context, IMendixObject OpenAIRequest, java.lang.String OpenAIRequest_Json)
	{
		super(context);
		this.__OpenAIRequest = OpenAIRequest;
		this.OpenAIRequest_Json = OpenAIRequest_Json;
	}

	@java.lang.Override
	public java.lang.String executeAction() throws Exception
	{
		this.OpenAIRequest = this.__OpenAIRequest == null ? null : openaiconnector.proxies.OpenAIRequest.initialize(getContext(), __OpenAIRequest);

		// BEGIN USER CODE
		try {
			requireNonNull(OpenAIRequest, "ChatCompletionsRequest is required.");
			requireNonNull(OpenAIRequest_Json, "ChatCompletionsRequest_Json is required.");

			rootNode = MAPPER.readTree(OpenAIRequest_Json);
			
			updateMessages(rootNode);
			//setFunctionToolChoice(rootNode);
			//mapFunctionParameters();

			return MAPPER.writeValueAsString(rootNode);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
			throw e;
		}
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "OpenAIRequest_ManipulateJson";
	}

	// BEGIN EXTRA CODE
	private static final MxLogger LOGGER = new MxLogger(OpenAIRequest_ManipulateJson.class);
	private static final ObjectMapper MAPPER = new ObjectMapper();
	private JsonNode rootNode;
	
	
	
	private void updateMessages(JsonNode rootNode) {
		//Get messages node
		JsonNode messagesNode = rootNode.path("messages");
		//Loop over all messages
		for (JsonNode messageNode : messagesNode) {
			//find tool_calls node and remove if array is empty
            removeEmptyToolCalls(messageNode);
            
            //If an imageCollection has been added replace content node with array of text content and image content
            //updateImageMessages(messageNode);
        }
		//Update messages within rootNode
		((ObjectNode) rootNode).set("messages", messagesNode);
	}

	private void removeEmptyToolCalls(JsonNode messageNode) {
		JsonNode toolCallsNode = messageNode.path("tool_calls");
		if (toolCallsNode != null && toolCallsNode.isArray() && toolCallsNode.size() == 0) {
		    ((ObjectNode) messageNode).remove("tool_calls");
		}
	}

	/*
	private void updateImageMessages(JsonNode messageNode) {
		JsonNode imageCollection = messageNode.path("imagecollection");
		
		//Return if there no images will be sent
		if(imageCollection == null || imageCollection.size() == 0) {
			return;
		}
		ArrayNode content = MAPPER.createArrayNode();
			
		//set text content string as first element in array
		ObjectNode textContent = MAPPER.createObjectNode();
		textContent.put("type", "text");
		textContent.put("text", messageNode.path("content").asText());
		content.add(textContent);
		
		//add image content to array
		for (JsonNode image : imageCollection) {
			ObjectNode imageURL = MAPPER.createObjectNode();
			imageURL.put("url", image.path("imagecontent").asText());
			
			if(image.path("detail") != null) {
				imageURL.put("detail", image.path("detail").asText());
			}
			
			ObjectNode imageContent = MAPPER.createObjectNode();
			imageContent.put("type", "image_url");
			imageContent.set("image_url", imageURL);
			content.add(imageContent);
		}
			
		//Remove imageCollection helper structure
		((ObjectNode) messageNode).remove("imagecollection");
		//Overwrite content node including images
		((ObjectNode) messageNode).set("content", content);
	}

	private void setFunctionToolChoice(JsonNode rootNode) throws CoreException {
		// ToolChoice is not function and thus empty, auto or none
		if (ChatCompletionsRequest.getToolChoice() == null || !ChatCompletionsRequest.getToolChoice().equals(ENUM_ToolChoice.function)) {
			return;

		// Add ToolChoice Function if it has not yet been called in a previous iteration
		} else {
			ToolRequest toolRequest = ChatCompletionsRequest.getChatCompletionsRequest_ToolRequest_ToolChoice();
			FunctionRequest functionRequest = toolRequest == null ? null : toolRequest.getToolRequest_FunctionRequest();
			
			// Remove tool choice function, because it has already been called
			// This prevents and infinite loop
			if (functionRequest == null || isToolRecall(functionRequest.getName())) {
				LOGGER.debug("ToolChoice function " + functionRequest.getName() + " has already been called. Removing ToolChoice from Request.");
				((ObjectNode)rootNode).remove("tool_choice");
			
			} else {
				// Create a new tool_choice node
		        ObjectNode toolChoiceNode = createFunctionToolChoiceNode(toolRequest, functionRequest);
		        LOGGER.debug("ToolChoice has not been called yet. Updating ToolChoice function placeholder with: " + toolChoiceNode);
		        
		        // Update the original JsonNode with the tool_choice object
		        ((ObjectNode) rootNode).set("tool_choice", toolChoiceNode);
			}
		}
	}
	
	private ObjectNode createFunctionToolChoiceNode(ToolRequest toolRequest, FunctionRequest functionRequest) {
		ObjectNode toolChoiceNode = MAPPER.createObjectNode();
        toolChoiceNode.put("type", toolRequest.getToolType().name());
        ObjectNode functionNode = MAPPER.createObjectNode();
        functionNode.put("name", functionRequest.getName());
        toolChoiceNode.set("function", functionNode);
        return toolChoiceNode;
	}

	private boolean isToolRecall(String toolChoiceFunctionName) throws CoreException {
		ChatCompletionsMessages chatCompletionsMessages = ChatCompletionsRequest
				.getChatCompletionsMessages_ChatCompletionsRequest();

		// Get all messages with role 'tool'
		List<ChatCompletionsMessageRequest> messageListTool = ChatCompletionsMessageRequestImpl
				.retrieveMessageListByRole(chatCompletionsMessages, ENUM_Role.tool, getContext());

		// No tool calls yet; thus no tool recall
		if (messageListTool.size() == 0) {
			return false;
		}

		// Get all messages with role assistant
		// Assistant messages optionally have an array of tool_calls that contain an id and the functionName
		List<ChatCompletionsMessageRequest> messageListAssistant = ChatCompletionsMessageRequestImpl
				.retrieveMessageListByRole(chatCompletionsMessages, ENUM_Role.assistant, getContext());

		// HashMap with ToolCall._id and ToolCallFunction.Name created from the messageListAssistant
		// The map contains only those tool calls, where functionName equals the toolChoiceFunctionName
		Map<String, String> toolChoiceToolCallMap = new HashMap<>();

		for (ChatCompletionsMessageRequest message : messageListAssistant) {

			// Get ToolCall list for each assistant message where the function name equals
			// the function name from the tool choice (toolChoiceFunctionName)
			List<ToolCall> toolCallList = Core.retrieveByPath(getContext(), message.getMendixObject(),
							ToolCall.MemberNames.ToolCall_AbstractChatCompletionsMessage.toString())
					.stream()
					.filter(mxObject -> {
						return filterToolCallByFunctionName(toolChoiceFunctionName, mxObject);
					})
					.map(mxObject -> ToolCall.initialize(getContext(), mxObject))
					.collect(Collectors.toList());

			// Loop over toolCallList and add _id and functionName to a HashMap
			for (ToolCall toolCall : toolCallList) {
				String toolCallId = toolCall.get_id();
				String functionName = toolCall.getToolCallFunction_ToolCall().getName();
				toolChoiceToolCallMap.put(toolCallId, functionName);
			}
		}

		// Loop over Tool messages and compare ToolCallId with Ids from Assistant
		// messages in HashMap to see whether the function from the Tool Choice has
		// already been called
		for (ChatCompletionsMessageRequest messageTool : messageListTool) {
			String toolId = messageTool.getToolCallId();
			if (toolChoiceToolCallMap.containsKey(toolId)) {
				return true;
			}
		}
		return false;
	}

	private boolean filterToolCallByFunctionName(String toolChoiceFunctionName, IMendixObject mxObject) {
		String functionName = "";
		try {
			functionName = ToolCall.initialize(getContext(), mxObject).getToolCallFunction_ToolCall().getName();
		} catch (CoreException e) {
			LOGGER.error(e);
		}
		// Return true if the functionName equals toolChoiceFunctionName
		return functionName.equals(toolChoiceFunctionName);
	}
	
	private void mapFunctionParameters() throws CoreException {
		Tools tools = ChatCompletionsRequest.getChatCompletionsRequest_Tools();
		if(tools == null) {
			return;
		}
		List<ToolRequest> toolRequestList = Core.retrieveByPath(getContext(),
				tools.getMendixObject(), ToolRequest.MemberNames.ToolRequest_Tools.toString())
				.stream()
				.map(mxObject -> ToolRequest.initialize(getContext(), mxObject))
				.collect(Collectors.toList());
		
		// Loop through all tools, find FunctionRequest object by functionName that contains the FunctionMicroflow,
		// get InputParameterName of the FunctionMicroflow, create parametersNode and add to toolNode
		JsonNode toolsNode = rootNode.path("tools");
		for (JsonNode toolNode : toolsNode) {
			String functionName = toolNode.path("function").path("name").asText();
			Optional<ToolRequest> toolRequestMatch = toolRequestList.stream()
					.filter(toolRequest -> {
						return filterToolRequestByFunctionName(functionName, toolRequest);
					})
					.findFirst();
			if(toolRequestMatch.isPresent()) {
				ObjectNode parametersNode = createFunctionParametersNode(toolRequestMatch.get().getToolRequest_FunctionRequest().getFunctionMicroflow());
				if(parametersNode != null) {
					JsonNode functionNode = toolNode.path("function");
					((ObjectNode) functionNode).set("parameters", parametersNode);
					((ObjectNode) toolNode).set("function", functionNode);
				}
			}
		}
		
		// Update tools within rootNode
		((ObjectNode) rootNode).set("tools", toolsNode);
	}

	private boolean filterToolRequestByFunctionName(String functionName, ToolRequest toolRequest) {
		try {
			return toolRequest.getToolRequest_FunctionRequest().getName().equals(functionName);
		} catch (CoreException e) {
			LOGGER.error(e);
		}
		return false;
	}
	
	private ObjectNode createFunctionParametersNode(String functionMicroflow) {
		String inputParamName = FunctionImpl.getFirstInputParamName(functionMicroflow);
		if (inputParamName == null || inputParamName.isBlank()) {
			return null;
		}

		ObjectNode parametersNode = MAPPER.createObjectNode();
		ObjectNode propertiesNode = MAPPER.createObjectNode();
		ObjectNode propertyNode = MAPPER.createObjectNode(); 
		ArrayNode requiredNode = MAPPER.createArrayNode();
		
		propertyNode.put("type", "string");
		
		propertiesNode.set(inputParamName, propertyNode);
		
		requiredNode.add(inputParamName);
		
		parametersNode.put("type", "object");
		parametersNode.set("properties", propertiesNode);
		parametersNode.set("required", requiredNode);
		
		return parametersNode;
	}
	*/
	
	// END EXTRA CODE
}
